\section*{Conclusion}
Porting the code to a GPU really does provide vast speed ups of the code. These can be seen more thoroughally with medium.vtk and large.vtk which take a very long time to run on the CPU.
However it is the parallelism that this algorithm specifically benefits from, we did not compare our GPU initial results with a parallelised version on the CPU (i.e. coloured). Still since the GPU supports far faster floating point manipulations, and a significantly higher number of threads than the CPU there is little to no question that it will run faster.
The CUDA Tool Kit also allows for an easy introduction into GPU programming so that even if you've never written code for a GPU makes it relatively straight foward and has come along way in the past few years. The use of CUDA benefitted this project's timescale rather than the less restrictive counter-part, OpenCL, due to the experience of the group members.

Furthermore the optimisations to the GPU did, on the whole did provide for better performance with the only exception being re-ordering the colours which was easy to reason about with profiling.

A big restriction to this project was making the decision not to run our code on cx1. Again given the timescale, this was the correct decision to make as it allowed us to make quick iterative improvements to the code. The down side, however, was having a GPU with compute capacity of 1.0 and this seriously restricted the profiling available to us and thus our ability to reason without speculation about results.
Also if we had used a GPU with compute capability $\ge$ 2.0 then the GPU would have had 32 cores\cite{compute_2.0}, opposed to only 8 and this the perfomance of the algorithm is likely to have been a lot better since there were a large amount of verticies in each colouring.